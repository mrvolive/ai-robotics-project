import cv2
import zmq
import numpy as np
from ultralytics import YOLO
from helpers.get_bounding_box import get_bounding_boxes
from helpers.get_diagonal import get_diagonal

HOST = "192.168.137.214"
PORT = 1807
FRAME_WIDTH = 224
FRAME_HEIGHT = 224
CHANNELS = 3


def main():
    model = YOLO('runs/detect/train3/weights/best.pt')

    # ZMQ subscriber
    context = zmq.Context()
    socket = context.socket(zmq.SUB)
    socket.setsockopt(zmq.SUBSCRIBE, b"")
    socket.connect(f"tcp://{HOST}:{PORT}")

    print("Connected to ZMQ stream, press 'q' to quit")

    while True:
        # Receive frame
        buf = socket.recv()
        frame = np.frombuffer(buf, dtype=np.uint8).reshape(
            (FRAME_HEIGHT, FRAME_WIDTH, CHANNELS)
        )

        # Run YOLO
        results = model(frame, conf=0.5)
        result = results[0]

        # Get bboxes info (list of dicts)
        boxes = get_bounding_boxes(result)

        annotated = frame.copy()

        for b in boxes:
            # Box corners
            x1 = int(b["left_bottom_x"])
            y1 = int(b["left_bottom_y"])
            x2 = int(b["right_top_x"])
            y2 = int(b["right_top_y"])
            conf = b["conf"]
            cls_name = b["class_name"]

            # Draw bbox (top-left, bottom-right)
            cv2.rectangle(annotated, (x1, y2), (x2, y1), (0, 255, 0), 2)

            # Line and its info
            slope, length, angle = get_diagonal(x1, y1, x2, y2)
            cv2.line(annotated, (x1, y1), (x2, y2), (255, 0, 0), 2)

            # Text for bbox
            text_box = f"{cls_name} {conf:.2f}"
            cv2.putText(
                annotated,
                text_box,
                (x1, max(0, y2 - 10)),
                cv2.FONT_HERSHEY_SIMPLEX,
                0.4,
                (0, 255, 0),
                1,
                cv2.LINE_AA,
            )

            # Text for line (center of line)
            cx = (x1 + x2) // 2
            cy = (y1 + y2) // 2
            if slope is None:
                slope_text = "inf"
            else:
                slope_text = f"{slope:.2f}"
            text_line = f"m={slope_text}, L={length:.1f}, a={angle:.1f}"
            cv2.putText(
                annotated,
                text_line,
                (cx, cy),
                cv2.FONT_HERSHEY_SIMPLEX,
                0.4,
                (255, 0, 0),
                1,
                cv2.LINE_AA,
            )

        cv2.imshow("Line detection", annotated)

        if cv2.waitKey(1) & 0xFF == ord("q"):
            break

    cv2.destroyAllWindows()


if __name__ == "__main__":
    main()
{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "from jetbot import Robot\n",
    "import traitlets\n",
    "import ipywidgets.widgets as widgets\n",
    "import numpy as np\n",
    "\n",
    "robot = Robot()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "image = widgets.Image(format='jpeg', width=300, height=300)\n",
    "\n",
    "display(image)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "from jetbot import Camera\n",
    "\n",
    "camera = Camera.instance()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "from jetbot import bgr8_to_jpeg\n",
    "\n",
    "camera_link = traitlets.dlink((camera, 'value'), (image, 'value'), transform=bgr8_to_jpeg)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "from jetbot import Heartbeat\n",
    "\n",
    "\n",
    "def handle_heartbeat_status(change):\n",
    "    if change['new'] == Heartbeat.Status.dead:\n",
    "        camera_link.unlink()\n",
    "        robot.stop()\n",
    "\n",
    "heartbeat = Heartbeat(period=0.5)\n",
    "\n",
    "# attach the callback function to heartbeat status\n",
    "heartbeat.observe(handle_heartbeat_status, names='status')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import cv2\n",
    "def preprocess(frame):\n",
    "    frame = cv2.medianBlur(frame, 3)\n",
    "    frame = cv2.addWeighted(frame, 1, np.zeros(frame.shape, frame.dtype), 0, 2)\n",
    "    frame = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)\n",
    "    return frame"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def get_two_line_centers(lines, img_width):\n",
    "    \"\"\"\n",
    "    Collect all line midpoints, divide by vertical center (x-axis),\n",
    "    and return mean point for left and right groups.\n",
    "    \"\"\"\n",
    "    if lines is None or len(lines) == 0:\n",
    "        return None, None\n",
    "    \n",
    "    # Collect all midpoints\n",
    "    midpoints = []\n",
    "    for line in lines:\n",
    "        x1, y1, x2, y2 = line[0]\n",
    "        mx = (x1 + x2) / 2\n",
    "        my = (y1 + y2) / 2\n",
    "        midpoints.append((mx, my))\n",
    "    \n",
    "    # Divide by vertical center (x-coordinate)\n",
    "    center_x = img_width / 2\n",
    "    left_points = [p for p in midpoints if p[0] < center_x]\n",
    "    right_points = [p for p in midpoints if p[0] >= center_x]\n",
    "    \n",
    "    # Calculate mean for each group\n",
    "    left_center = None\n",
    "    right_center = None\n",
    "    \n",
    "    if left_points:\n",
    "        left_x = np.mean([p[0] for p in left_points])\n",
    "        left_y = np.mean([p[1] for p in left_points])\n",
    "        left_center = (int(left_x), int(left_y))\n",
    "    \n",
    "    if right_points:\n",
    "        right_x = np.mean([p[0] for p in right_points])\n",
    "        right_y = np.mean([p[1] for p in right_points])\n",
    "        right_center = (int(right_x), int(right_y))\n",
    "    \n",
    "    return left_center, right_center\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def calculate_steering(left_center, right_center, img_width, k=1.0):\n",
    "    if left_center is not None and right_center is not None:\n",
    "        lane_center_x = (left_center[0] + right_center[0]) / 2\n",
    "        lane_center_y = (left_center[1] + right_center[1]) / 2\n",
    "        lane_center = (int(lane_center_x), int(lane_center_y))\n",
    "    \n",
    "    # If only one line detected, estimate lane center\n",
    "    elif left_center is not None:\n",
    "        # Assume lane width and estimate right side\n",
    "        estimated_lane_width = img_width * 0.4  # Adjust based on your lane\n",
    "        lane_center_x = left_center[0] + estimated_lane_width / 2\n",
    "        lane_center_y = left_center[1]\n",
    "        lane_center = (int(lane_center_x), int(lane_center_y))\n",
    "    \n",
    "    elif right_center is not None:\n",
    "        # Assume lane width and estimate left side\n",
    "        estimated_lane_width = img_width * 0.4\n",
    "        lane_center_x = right_center[0] - estimated_lane_width / 2\n",
    "        lane_center_y = right_center[1]\n",
    "        lane_center = (int(lane_center_x), int(lane_center_y))\n",
    "    \n",
    "    else:\n",
    "        # No lines detected\n",
    "        return 0.0, None\n",
    "    \n",
    "    # Calculate steering error\n",
    "    image_center_x = img_width / 2\n",
    "    error_x = lane_center[0] - image_center_x\n",
    "    \n",
    "    # Normalize to [-1, 1]\n",
    "    max_offset = img_width / 2\n",
    "    normalized_error = error_x / max_offset\n",
    "    \n",
    "    # Apply gain and clamp\n",
    "    steering = k * normalized_error\n",
    "    steering = max(-1.0, min(1.0, steering))\n",
    "    \n",
    "    return steering, lane_center"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Kinematics:\n",
    "    \"\"\"Handle robot kinematics calculations\"\"\"\n",
    "    \n",
    "    def __init__(self, wheel_radius, wheel_distance, pulses_per_turn):\n",
    "        self.wheel_radius = wheel_radius\n",
    "        self.wheel_distance = wheel_distance\n",
    "        self.pulses_per_turn = pulses_per_turn\n",
    "    \n",
    "    def wheel_speed_commands(self, u_desired, w_desired):\n",
    "        wr_desired = float((2*u_desired + self.wheel_distance*w_desired) / (2*self.wheel_radius))\n",
    "        wl_desired = float((2*u_desired - self.wheel_distance*w_desired) / (2*self.wheel_radius))\n",
    "        return wl_desired, wr_desired\n",
    "    \n",
    "    def get_angular_and_linear_speed(self, wl, wr):\n",
    "\n",
    "        u = self.wheel_radius / 2.0 * (wr + wl)\n",
    "        w = self.wheel_radius / self.wheel_distance * (wr - wl)\n",
    "        return u, w\n",
    "    \n",
    "    def get_wheel_speed(self, encoders, old_encoders, delta_t):\n",
    "        ang_diff_l = 2*np.pi*(encoders[0] - old_encoders[0]) / self.pulses_per_turn\n",
    "        ang_diff_r = 2*np.pi*(encoders[1] - old_encoders[1]) / self.pulses_per_turn\n",
    "        \n",
    "        wl = ang_diff_l / delta_t\n",
    "        wr = ang_diff_r / delta_t\n",
    "        \n",
    "        return wl, wr\n",
    "    \n",
    "    def get_robot_pose(self, u, w, x_old, y_old, phi_old, delta_t):\n",
    "        delta_phi = w * delta_t\n",
    "        phi = phi_old + delta_phi\n",
    "        \n",
    "        # Normalize angle to [-pi, pi]\n",
    "        if phi >= np.pi:\n",
    "            phi = phi - 2*np.pi\n",
    "        elif phi < -np.pi:\n",
    "            phi = phi + 2*np.pi\n",
    "        \n",
    "        delta_x = u * np.cos(phi) * delta_t\n",
    "        delta_y = u * np.sin(phi) * delta_t\n",
    "        x = x_old + delta_x\n",
    "        y = y_old + delta_y\n",
    "        \n",
    "        return x, y, phi\n",
    "    \n",
    "    def update_pose(self, encoder_values):\n",
    "        wl, wr = self.kinematics.get_wheel_speed(\n",
    "            encoder_values, \n",
    "            self.old_encoder_values, \n",
    "            self.delta_t\n",
    "        )\n",
    "        \n",
    "        # Get robot speeds\n",
    "        u, w = self.kinematics.get_angular_and_linear_speed(wl, wr)\n",
    "        \n",
    "        # Update pose\n",
    "        self.x, self.y, self.phi = self.kinematics.get_robot_pose(\n",
    "            u, w, self.x, self.y, self.phi, self.delta_t\n",
    "        )\n",
    "        \n",
    "        # Update old encoder values\n",
    "        self.old_encoder_values = encoder_values\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "WHEEL_RADIUS = 0.325\n",
    "WHEEL_DISTANCE = 0.15\n",
    "PULSES_PER_TURN = 330\n",
    "\n",
    "kinematics = Kinematics(WHEEL_RADIUS, WHEEL_DISTANCE, PULSES_PER_TURN)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "left_speed, right_speed = kinematics.wheel_speed_commands(0, 0)\n",
    "robot.set_motors(left_speed, right_speed)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "prev_steering = 0.0\n",
    "alpha = 0.2\n",
    "while True:\n",
    "    image_aux = preprocess(camera.value)\n",
    "    h, w = camera.value.shape[:2]\n",
    "    sliced_image = camera.value[int(h*0.5):h, :, :]\n",
    "\n",
    "    CANNY_THRESHOLD = 70\n",
    "    edges = cv2.Canny(image_aux, CANNY_THRESHOLD, CANNY_THRESHOLD * 1.1)\n",
    "\n",
    "    h, w = edges.shape[:2]\n",
    "    edges = edges[int(h*0.5):h, :]\n",
    "\n",
    "    lines = cv2.HoughLinesP(\n",
    "        edges,\n",
    "        1,\n",
    "        np.pi/180,\n",
    "        50,\n",
    "        minLineLength=10,\n",
    "        maxLineGap=50\n",
    "    )\n",
    "    steering = 0.0\n",
    "    steering_limited = 0.0\n",
    "        \n",
    "    if lines is not None:\n",
    "        # Get the two mean centers\n",
    "        left_center, right_center = get_two_line_centers(lines, sliced_image.shape[1])\n",
    "\n",
    "        # Calculate steering angle\n",
    "        steering, lane_center = calculate_steering(\n",
    "            left_center, \n",
    "            right_center, \n",
    "            sliced_image.shape[1],\n",
    "            k=2  # Adjust gain for your robot's responsiveness\n",
    "        )\n",
    "        prev_steering = (1 - alpha) * prev_steering + alpha * steering\n",
    "        smoothed = prev_steering\n",
    "        steering_limited = max(-0.5, min(0.5, steering))\n",
    "    left_speed, right_speed = kinematics.wheel_speed_commands(0.1, steering_limited)\n",
    "    robot.set_motors(left_speed, right_speed)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "robot.stop()\n",
    "camera.stop()"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.9"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0d7944a1",
   "metadata": {},
   "outputs": [],
   "source": [
    "from jetbot import Robot\n",
    "import traitlets\n",
    "import ipywidgets.widgets as widgets\n",
    "import time\n",
    "\n",
    "from jetbot import bgr8_to_jpeg\n",
    "from jetbot import Heartbeat\n",
    "import numpy as np\n",
    "import traitlets\n",
    "import ipywidgets.widgets as widgets\n",
    "import time\n",
    "import sys\n",
    "import select\n",
    "import tty\n",
    "import cv2\n",
    "from enum import Enum, auto\n",
    "\n",
    "robot = Robot()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "2ff61072",
   "metadata": {},
   "outputs": [],
   "source": [
    "class Kinematics:\n",
    "    \"\"\"Handle robot kinematics calculations\"\"\"\n",
    "    \n",
    "    def __init__(self, wheel_radius, wheel_distance, pulses_per_turn):\n",
    "        self.wheel_radius = wheel_radius\n",
    "        self.wheel_distance = wheel_distance\n",
    "        self.pulses_per_turn = pulses_per_turn\n",
    "    \n",
    "    def wheel_speed_commands(self, u_desired, w_desired):\n",
    "        \"\"\"Converts desired speeds to wheel speed commands\"\"\"\n",
    "        wr_desired = float((2*u_desired + self.wheel_distance*w_desired) / (2*self.wheel_radius))\n",
    "        wl_desired = float((2*u_desired - self.wheel_distance*w_desired) / (2*self.wheel_radius))\n",
    "        return wl_desired, wr_desired\n",
    "    \n",
    "    def get_angular_and_linear_speed(self, wl, wr):\n",
    "        \"\"\"Calculate robot linear and angular speeds from wheel speeds\"\"\"\n",
    "        u = self.wheel_radius / 2.0 * (wr + wl)\n",
    "        w = self.wheel_radius / self.wheel_distance * (wr - wl)\n",
    "        return u, w\n",
    "    \n",
    "    def get_wheel_speed(self, encoders, old_encoders, delta_t):\n",
    "        \"\"\"Calculate wheel speeds from encoder values\"\"\"\n",
    "        ang_diff_l = 2*np.pi*(encoders[0] - old_encoders[0]) / self.pulses_per_turn\n",
    "        ang_diff_r = 2*np.pi*(encoders[1] - old_encoders[1]) / self.pulses_per_turn\n",
    "        \n",
    "        wl = ang_diff_l / delta_t\n",
    "        wr = ang_diff_r / delta_t\n",
    "        \n",
    "        return wl, wr\n",
    "    \n",
    "    def get_robot_pose(self, u, w, x_old, y_old, phi_old, delta_t):\n",
    "        \"\"\"Calculate robot pose from velocities\"\"\"\n",
    "        delta_phi = w * delta_t\n",
    "        phi = phi_old + delta_phi\n",
    "        \n",
    "        # Normalize angle to [-pi, pi]\n",
    "        if phi >= np.pi:\n",
    "            phi = phi - 2*np.pi\n",
    "        elif phi < -np.pi:\n",
    "            phi = phi + 2*np.pi\n",
    "        \n",
    "        delta_x = u * np.cos(phi) * delta_t\n",
    "        delta_y = u * np.sin(phi) * delta_t\n",
    "        x = x_old + delta_x\n",
    "        y = y_old + delta_y\n",
    "        \n",
    "        return x, y, phi"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d9393151",
   "metadata": {},
   "outputs": [],
   "source": [
    "class State(Enum):\n",
    "    FOLLOWING_LINE = auto()\n",
    "    RIGHT_DODGE = auto()\n",
    "    LEFT_DODGE = auto()\n",
    "    STOP_SIGN = auto()\n",
    "    TURN_RIGHT_SIGN = auto()\n",
    "    TURN_LEFT_SIGN = auto()\n",
    "    SHARP_TURN_LEFT = auto()\n",
    "    SHARP_TURN_RIGHT = auto()\n",
    "    FORWARD = auto()\n",
    "    FORB_AHEAD = auto"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "6da20ace",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "17731ae2",
   "metadata": {},
   "outputs": [],
   "source": [
    "SIGN_TO_STATE = {\n",
    "    \"forb_ahead\": State.FORB_AHEAD,\n",
    "    \"mand_left\": State.TURN_LEFT_SIGN,\n",
    "    \"mand_right\": State.TURN_RIGHT_SIGN,\n",
    "    \"prio_stop\": State.STOP_SIGN\n",
    "}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "a04ad91b",
   "metadata": {},
   "outputs": [],
   "source": [
    "class RobotController:\n",
    "    def __init__(self):\n",
    "        # Hardware Setup\n",
    "        self.robot = Robot()\n",
    "        self.camera = Camera(width=320, height=320)\n",
    "\n",
    "        # Kinematics Setup\n",
    "        self.WHEEL_RADIUS = 0.325\n",
    "        self.WHEEL_DISTANCE = 0.15\n",
    "        self.PULSES_PER_TURN = 330\n",
    "        self.kinematics = Kinematics(self.WHEEL_RADIUS, self.WHEEL_DISTANCE, self.PULSES_PER_TURN)\n",
    "        \n",
    "        # State Machine Setup\n",
    "        self.current_state = State.FOLLOWING_LINE\n",
    "        self.state_start_time = time.time()\n",
    "        self.dodge_phase = 0\n",
    "        \n",
    "        # Control Variables\n",
    "        self.prev_steering = 0.0\n",
    "        self.alpha = 0.2\n",
    "        self.base_speed = 0.2\n",
    "        \n",
    "        # Heartbeat to stop robot if connection lost\n",
    "        self.heartbeat = Heartbeat(period=0.5)\n",
    "        self.heartbeat.observe(self.handle_heartbeat_status, names='status')\n",
    "        \n",
    "        print(f\"RobotController initialized. Starting in {self.current_state} state.\")\n",
    "\n",
    "    def handle_heartbeat_status(self, change):\n",
    "        if change['new'] == Heartbeat.Status.dead:\n",
    "            self.robot.stop()\n",
    "    def after_sign(self):\n",
    "        self.run_forward()\n",
    "        time.sleep(5)\n",
    "        \n",
    "\n",
    "    def preprocess(self, frame):\n",
    "        frame = cv2.medianBlur(frame, 3)\n",
    "        frame = cv2.addWeighted(frame, 1, np.zeros(frame.shape, frame.dtype), 0, 2)\n",
    "        frame = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)\n",
    "        return frame\n",
    "\n",
    "    def get_two_line_centers(self, lines, img_width):\n",
    "        if lines is None or len(lines) == 0:\n",
    "            return None, None\n",
    "        \n",
    "        midpoints = []\n",
    "        for line in lines:\n",
    "            x1, y1, x2, y2 = line[0]\n",
    "            mx = (x1 + x2) / 2\n",
    "            my = (y1 + y2) / 2\n",
    "            midpoints.append((mx, my))\n",
    "        \n",
    "        center_x = img_width / 2\n",
    "        left_points = [p for p in midpoints if p[0] < center_x]\n",
    "        right_points = [p for p in midpoints if p[0] >= center_x]\n",
    "        \n",
    "        left_center = None\n",
    "        right_center = None\n",
    "        \n",
    "        if left_points:\n",
    "            left_x = np.mean([p[0] for p in left_points])\n",
    "            left_y = np.mean([p[1] for p in left_points])\n",
    "            left_center = (int(left_x), int(left_y))\n",
    "        \n",
    "        if right_points:\n",
    "            right_x = np.mean([p[0] for p in right_points])\n",
    "            right_y = np.mean([p[1] for p in right_points])\n",
    "            right_center = (int(right_x), int(right_y))\n",
    "        \n",
    "        return left_center, right_center\n",
    "\n",
    "    def calculate_steering(self, left_center, right_center, img_width, k=1.0):\n",
    "        if left_center is not None and right_center is not None:\n",
    "            lane_center_x = (left_center[0] + right_center[0]) / 2\n",
    "            lane_center_y = (left_center[1] + right_center[1]) / 2\n",
    "            lane_center = (int(lane_center_x), int(lane_center_y))\n",
    "        elif left_center is not None:\n",
    "            estimated_lane_width = img_width * 0.4\n",
    "            lane_center_x = left_center[0] + estimated_lane_width / 2\n",
    "            lane_center_y = left_center[1]\n",
    "            lane_center = (int(lane_center_x), int(lane_center_y))\n",
    "        elif right_center is not None:\n",
    "            estimated_lane_width = img_width * 0.4\n",
    "            lane_center_x = right_center[0] - estimated_lane_width / 2\n",
    "            lane_center_y = right_center[1]\n",
    "            lane_center = (int(lane_center_x), int(lane_center_y))\n",
    "        else:\n",
    "            return 0.0, None\n",
    "        \n",
    "        image_center_x = img_width / 2\n",
    "        error_x = lane_center[0] - image_center_x\n",
    "        max_offset = img_width / 2\n",
    "        normalized_error = error_x / max_offset\n",
    "        steering = k * normalized_error\n",
    "        steering = max(-1.0, min(1.0, steering))\n",
    "        \n",
    "        return steering, lane_center\n",
    "\n",
    "    def transition_to(self, new_state):\n",
    "        if self.current_state != new_state:\n",
    "            print(f\"Transitioning from {self.current_state.name} to {new_state.name}\")\n",
    "            self.current_state = new_state\n",
    "            self.state_start_time = time.time()\n",
    "\n",
    "    def run_following_line(self):\n",
    "        # 1. Get Image\n",
    "        if self.camera.value is None:\n",
    "            return\n",
    "            \n",
    "        image_aux = self.preprocess(self.camera.value)\n",
    "        h, w = self.camera.value.shape[:2]\n",
    "        sliced_image = self.camera.value[int(h*0.5):h, :, :]\n",
    "        \n",
    "        CANNY_THRESHOLD = 70\n",
    "        edges = cv2.Canny(image_aux, CANNY_THRESHOLD, CANNY_THRESHOLD * 1.1)\n",
    "        h_edge, w_edge = edges.shape[:2]\n",
    "        edges = edges[int(h_edge*0.5):h_edge, :]\n",
    "        \n",
    "        lines = cv2.HoughLinesP(\n",
    "            edges, 1, np.pi/180, 50, minLineLength=10, maxLineGap=50\n",
    "        )\n",
    "        \n",
    "        steering = 0.0\n",
    "        steering_limited = 0.0\n",
    "        \n",
    "        if lines is not None:\n",
    "            left_center, right_center = self.get_two_line_centers(lines, sliced_image.shape[1])\n",
    "            steering, _ = self.calculate_steering(\n",
    "                left_center, right_center, sliced_image.shape[1], k=0.5\n",
    "            )\n",
    "            \n",
    "            # Smoothing\n",
    "            self.prev_steering = (1 - self.alpha) * self.prev_steering + self.alpha * steering\n",
    "            steering_limited = max(-0.5, min(0.5, self.prev_steering))\n",
    "            \n",
    "        # Drive\n",
    "        left_speed, right_speed = self.kinematics.wheel_speed_commands(0.08, steering_limited)\n",
    "        self.robot.set_motors(left_speed, right_speed)\n",
    "\n",
    "    def run_stop_sign(self):\n",
    "        self.robot.stop()\n",
    "        time.sleep(2)\n",
    "        self.after_sign()\n",
    "        self.transition_to(State.FOLLOWING_LINE)\n",
    "    def run_forb_ahead(self):\n",
    "        time.sleep(1)\n",
    "        self.robot.set_motors(-0.16, 0.16)\n",
    "        time.sleep(2)\n",
    "        self.transition_to(State.FOLLOWING_LINE)\n",
    "\n",
    "    def run_turn_sign(self, direction='right'):\n",
    "        time.sleep(1)\n",
    "        if direction == 'right':\n",
    "            self.robot.set_motors(0.10, -0.10)\n",
    "        if direction == 'left':\n",
    "            self.robot.set_motors(-0.10, 0.10)\n",
    "        time.sleep(2)\n",
    "        self.transition_to(State.FOLLOWING_LINE)\n",
    "    def run_forward(self):\n",
    "        self.robot.set_motors(self.base_speed, self.base_speed)\n",
    "            \n",
    "    def update(self, old_state):\n",
    "        if old_state == self.current_state:\n",
    "            return\n",
    "        if self.current_state == State.FORWARD:\n",
    "            self.run_forward()\n",
    "            \n",
    "        elif self.current_state == State.FOLLOWING_LINE:\n",
    "            self.run_following_line()\n",
    "            \n",
    "        elif self.current_state == State.STOP_SIGN:\n",
    "            self.run_stop_sign()\n",
    "            \n",
    "        elif self.current_state == State.TURN_RIGHT_SIGN:\n",
    "            self.run_turn_sign(direction='right')\n",
    "            \n",
    "        elif self.current_state == State.TURN_LEFT_SIGN:\n",
    "            self.run_turn_sign(direction='left')\n",
    "        elif self.current_state == State.FORB_AHEAD:\n",
    "            self.run_forb_ahead()\n",
    "\n",
    "    def handle_state_change(self, state):\n",
    "        if self.camera.value is None:\n",
    "            return\n",
    "        if state == 'forb_ahead':\n",
    "            self.transition_to(State.FORB_AHEAD)\n",
    "        elif state == 'mand_left':\n",
    "            self.transition_to(State.TURN_LEFT_SIGN)\n",
    "        elif state == 'mand_right':\n",
    "            self.transition_to(State.TURN_RIGHT_SIGN)\n",
    "        elif state == 'prio_stop':\n",
    "            self.transition_to(State.STOP_SIGN)\n",
    "        else:\n",
    "            pass\n",
    "                               \n",
    "    def start(self):\n",
    "        # ----------------------------\n",
    "        # CONFIG\n",
    "        # ----------------------------\n",
    "        # WINDOWS_IP = \"192.168.137.42\"\n",
    "        WINDOWS_IP = \"192.168.137.128\"\n",
    "\n",
    "\n",
    "        VIDEO_PORT = 5555\n",
    "        CTRL_PORT  = 5556\n",
    "\n",
    "        QUALITY = 80\n",
    "        TARGET_FPS = 20\n",
    "        DT = 1.0 / TARGET_FPS\n",
    "\n",
    "        ctx = zmq.Context()\n",
    "\n",
    "        # Video publisher (Jetson -> Windows)\n",
    "        pub = ctx.socket(zmq.PUB)\n",
    "        pub.setsockopt(zmq.CONFLATE, 1)\n",
    "        pub.setsockopt(zmq.SNDHWM, 1)\n",
    "        pub.connect(f\"tcp://{WINDOWS_IP}:{VIDEO_PORT}\")\n",
    "\n",
    "        # Control subscriber (Windows -> Jetson)\n",
    "        sub = ctx.socket(zmq.SUB)\n",
    "        sub.setsockopt(zmq.SUBSCRIBE, b\"\")\n",
    "        sub.setsockopt(zmq.RCVTIMEO, 50)   # short timeout keeps loop responsive\n",
    "        sub.setsockopt(zmq.CONFLATE, 1)\n",
    "        sub.setsockopt(zmq.RCVHWM, 1)\n",
    "        sub.connect(f\"tcp://{WINDOWS_IP}:{CTRL_PORT}\")\n",
    "\n",
    "        # ----------------------------\n",
    "        # ROBOT + CAMERA\n",
    "        # ----------------------------\n",
    "        robot = Robot()\n",
    "\n",
    "        time.sleep(0.5)  # allow sockets to connect (slow joiner)\n",
    "\n",
    "        last_cmd_t = time.time()\n",
    "        last_fps_t = time.time()\n",
    "        frames = 0\n",
    "\n",
    "        print(\"Started: streaming video + receiving control\")\n",
    "\n",
    "        try:\n",
    "            while True:\n",
    "                t0 = time.time()\n",
    "                self.update('')\n",
    "                # -------- VIDEO SEND --------\n",
    "                frame = self.camera.value\n",
    "                if frame is not None:\n",
    "                    ok, enc = cv2.imencode(\".jpg\", frame, [cv2.IMWRITE_JPEG_QUALITY, QUALITY])\n",
    "                    if ok:\n",
    "                        pub.send(enc.tobytes())\n",
    "                        frames += 1\n",
    "\n",
    "                # -------- CONTROL RECEIVE (non-blocking via timeout) --------\n",
    "                try:\n",
    "                    msg = sub.recv_string()      # raises zmq.Again on timeout\n",
    "                    data = json.loads(msg)\n",
    "                    state  = data.get(\"state\")\n",
    "                    if state != None:\n",
    "                        old_state = self.current_state\n",
    "                        self.handle_state_change(state)\n",
    "                        self.update(old_state)\n",
    "                        state = None\n",
    "                    else:\n",
    "                        self.run_following_line()\n",
    "\n",
    "                    print(f\"state: {state}\")\n",
    "\n",
    "                    # robot.set_motors(left, right)\n",
    "                    last_cmd_t = time.time()\n",
    "\n",
    "                    # optional debug\n",
    "                    # print(f\"linear={linear:.2f} angular={angular:.2f} -> L={left:.2f} R={right:.2f}\")\n",
    "\n",
    "                except zmq.Again:\n",
    "                    # No new command this loop\n",
    "                    pass\n",
    "\n",
    "                # -------- SAFETY STOP --------\n",
    "                if time.time() - last_cmd_t > 0.5:\n",
    "                    robot.stop()\n",
    "\n",
    "                # -------- FPS PRINT --------\n",
    "                if time.time() - last_fps_t >= 1.0:\n",
    "        #             print(\"fps:\", frames)\n",
    "                    frames = 0\n",
    "                    last_fps_t = time.time()\n",
    "\n",
    "                # -------- RATE LIMIT --------\n",
    "                sleep = DT - (time.time() - t0)\n",
    "                if sleep > 0:\n",
    "                    time.sleep(sleep)\n",
    "\n",
    "        except KeyboardInterrupt:\n",
    "            print(\"Stopped by user\")\n",
    "\n",
    "        finally:\n",
    "            robot.stop()\n",
    "            pub.close()\n",
    "            sub.close()\n",
    "            ctx.term()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f9063b12",
   "metadata": {},
   "outputs": [],
   "source": [
    "import zmq\n",
    "import json\n",
    "import time\n",
    "from jetbot import Robot\n",
    "robot = Robot()\n",
    "class Kinematics:\n",
    "    \"\"\"Handle robot kinematics calculations\"\"\"\n",
    "    \n",
    "    def __init__(self, wheel_radius, wheel_distance, pulses_per_turn):\n",
    "        self.wheel_radius = wheel_radius\n",
    "        self.wheel_distance = wheel_distance\n",
    "        self.pulses_per_turn = pulses_per_turn\n",
    "    \n",
    "    def wheel_speed_commands(self, u_desired, w_desired):\n",
    "        \"\"\"Converts desired speeds to wheel speed commands\n",
    "        \n",
    "        Args:\n",
    "            u_desired: Desired linear speed [m/s]\n",
    "            w_desired: Desired angular speed [rad/s]\n",
    "            \n",
    "        Returns:\n",
    "            Tuple of (wl_desired, wr_desired) wheel speeds [rad/s]\n",
    "        \"\"\"\n",
    "        wr_desired = float((2*u_desired + self.wheel_distance*w_desired) / (2*self.wheel_radius))\n",
    "        wl_desired = float((2*u_desired - self.wheel_distance*w_desired) / (2*self.wheel_radius))\n",
    "        return wl_desired, wr_desired\n",
    "WHEEL_RADIUS = 0.325\n",
    "WHEEL_DISTANCE = 0.15\n",
    "PULSES_PER_TURN = 330\n",
    "\n",
    "kinematics = Kinematics(WHEEL_RADIUS, WHEEL_DISTANCE, PULSES_PER_TURN)   \n",
    "left_speed, right_speed = kinematics.wheel_speed_commands(0, 0)\n",
    "robot.set_motors(left_speed, right_speed)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d4805f69",
   "metadata": {},
   "outputs": [],
   "source": [
    "import zmq\n",
    "import time\n",
    "import cv2\n",
    "import json\n",
    "\n",
    "from jetbot import Camera, Robot\n",
    "controller = RobotController()         \n",
    "controller.start()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0bdc3a3b",
   "metadata": {},
   "outputs": [],
   "source": [
    "controller.camera.stop()"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "base",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "name": "python",
   "version": "3.13.11"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
